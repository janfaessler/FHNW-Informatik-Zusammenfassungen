\documentclass[a4paper,10pt]{article}


\usepackage{listings}

%Math
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{ulem}
\usepackage{stmaryrd} %f\UTF{00FC}r Blitz!

%PageStyle
\usepackage[german]{babel}
\usepackage{fontenc}
\usepackage{fancyhdr, graphicx}
\usepackage{wasysym}
\usepackage{fullpage}
\usepackage{textcomp}
\usepackage{fancyhdr} %for header/footer

%My Commands
\newcommand{\BN}{\mathbb{B}} %BOOL
\newcommand{\RN}{\mathbb{R}} %Real Number
\newcommand{\NN}{\mathbb{N}} %Natural Number
\newcommand{\QN}{\mathbb{Q}} %Rational Number
\newcommand{\ZN}{\mathbb{Z}} %ganze Zahlen
\newcommand{\CN}{\mathbb{C}}
\newcommand{\Teilt}{\mid} %|
\newcommand{\Teiltn}{\nmid} %kein teiler
\newcommand{\Potp}{\mathcal{P}} %Potenzmenge
\newcommand{\Pota}{\mathcal{A}}
\newcommand{\Potr}{\mathcal{R}}
\newcommand{\Potn}{\mathcal{N}}
\newcommand{\Bold}[1]{\textbf{#1}} %Boldface
\newcommand{\Kursiv}[1]{\textit{#1}} %Italic
\newcommand{\T}[1]{\text{#1}} %Textmode
\newcommand{\Nicht}[1]{\T{\sout{$ #1 $}}} %Streicht Shit durch
\newcommand{\lra}{\leftrightarrow} %Arrows
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}
\newcommand{\lral}{\longleftrightarrow}
\newcommand{\ral}{\longrightarrow}
\newcommand{\lal}{\longleftarrow}
\newcommand{\Lra}{\Leftrightarrow}
\newcommand{\Ra}{\Rightarrow}
\newcommand{\La}{\Leftarrow}
\newcommand{\Lral}{\Longleftrightarrow}
\newcommand{\Ral}{\Longrightarrow}
\newcommand{\Lal}{\Longleftarrow}
\newcommand{\Vektor}[1]{\vec{#1}}
\newcommand{\Brace}[1]{\left( #1 \right)} %()
\newcommand{\Bracel}[1]{\left\lbrace #1 \right.} %(
\newcommand{\Bracer}[1]{\right. #1 \right\rbrace} %)
\newcommand{\Brack}[1]{\left\lbrace #1 \right\rbrace} %{}
\newcommand{\Brackl}[1]{\left\lbrace #1 \right.} %{
\newcommand{\Brackr}[1]{\right. #1 \right\rbrace} %}
\newcommand{\Result}[1]{\underline{\underline{#1}}} %Doppelt unterstrichen
\newcommand{\Abs}[1]{\left| #1 \right|} %Absolutbetrag
\newcommand{\Norm}[1]{\Abs{\Abs{ #1 }}} %Norm
\newcommand{\Arrays}[1]{\left(\begin{array}{c}#1\end{array}\right)} %Array mit einer Kolonne ()
\newcommand{\Array}[2]{\left(\begin{array}{#1}#2\end{array}\right)} %Array mit n Kolonnen ()
\newcommand{\Bracka}[2]{\left\lbrace\begin{array}{#1}#2\end{array}\right\rbrace} %Array mit {}
\newcommand{\Brackal}[2]{\left\lbrace\begin{array}{#1} #2 \end{array}\right.} %Array mit {
\newcommand{\Brackar}[2]{\left.\begin{array}{#1} #2 \end{array}\right\rbrace} %Array mit }
\newcommand{\Sumone}[2]{\sum_{#2=1}^{#1}} %Summe von 1
\newcommand{\Sumz}[2]{\sum_{#2=0}^{#1}} %Summe von 0
\newcommand{\Sum}[2]{\sum_{#2}^{#1}} %Allgemeine Summe
\newcommand{\Oneover}[1]{\frac{1}{#1}} %1 \UTF{00FC}ber igendwas
\newcommand{\Tablewt}[3]{\begin{table*}[h]\caption{#1} \begin{tabular}{#2}{#3}\end{tabular}\end{table*}} %Table mit Titel
\newcommand{\Oben}[2]{\overset{#1}{#2}} %etwas \UTF{00FC}ber etwas anderem
\newcommand{\Unten}[2]{\underset{#1}{#2}} %etwas unter etwas anderem
\newcommand{\Bildcap}[2]{\begin{figure}[htb]\centering\includegraphics[width=0.2\textwidth]{#1} \caption{#2}\end{figure}} %Bild mit beschriftung
\newcommand{\Bildjpeg}[1]{\includegraphics[width=0.2\textwidth]{#1.jpeg}} %Bilder jpeg!!
\newcommand{\Bildjpg}[1]{\includegraphics[width=0.2\textwidth]{#1.jpg}} %Bilder jpg!!

%Zeichnung
\usepackage{tikz}
\usepackage[all]{xy}
\usepackage{ucs}

%Config
\renewcommand{\headrulewidth}{0pt}
\setlength{\headheight}{15.2pt}
\pagestyle{plain}

%Metadata
\title{Algorithmen und Datenstrukturen}
\author{Jan F\"assler}
\date{2. Semester (FS 2012)}
\fancyfoot[C]{Jan F\"assler}

\begin{document}
\maketitle
\newpage
\thispagestyle{fancy} %f\UTF{00FC}r Header

\section{Daten \& Informationenen}

\subsection{Digitaltechnik}
\begin{tabular}{l l l}
	1 & low & 0 bis 0.8V \\
	0 & high & 2.4 bis 5V
\end{tabular} \\ \\
Mit einer Bitfolge der L\"ange n k\"onnen $2^n$ verschiedene Zust\"ande codiert werden.

\subsection{Byte}
\begin{itemize}
	\item geordnete Bitfolge der L\"ange 8 (256 Zust\"ande)
	\item Bits werden mit Indizes von 0 bis 7 nummeriert
	\item LSB (Least Significant Bit)
	\item MSB (Most Significant Bit)
\end{itemize}
\begin{tabular}{l l}
	KiByte & $2^{10}$ Byte \\
	MiByte & $2^{20}$ Byte \\
	GiByte & $2^{30}$ Byte \\
\end{tabular}

\subsection{Daten \& Informationenen}
Bitfolgen sind lediglich Daten und werden nach der Interpretation zu Informationen. \\ \\
Interpretationsarten sind Datentypen
\begin{itemize}
	\item Interpretation als ganze Zahl
	\item Interpretation als Gleitkommazahl
	\item Interpretation als alphanumerisches Zeichen
	\item benutzerdefinierte Interpretation
\end{itemize}

\subsection{Positive Zahlen}
\begin{tabular}{c c c c c c c c}
	MSP & & & & & & & LSB \\
	1 & 0 & 1 & 0 & 0 & 1 & 1 & 1 \\
	$2^7$ & $2^6$ & $2^5$ & $2^4$ & $2^3$ & $2^2$ & $2^1$ & $2^0$
\end{tabular}
In Java nur char (16 Bit) \\ \\ \\
$1*2^7+1*2^5+1*2^2+1*2^1+1*2^0=128+32+4+2+1=\uuline{167}$

\subsection{Ganze Zahlen (2er - Komplement)}
\begin{tabular}{c c c c c c c c}
	1 & 0 & 1 & 0 & 0 & 1 & 1 & 1 \\
	$2^7$ & $2^6$ & $2^5$ & $2^4$ & $2^3$ & $2^2$ & $2^1$ & $2^0$
\end{tabular} 
In Java: long (64 Bit), int (32 Bit), short (16 Bit) \& byte (8 Bit) \\ \\ \\
$-1*2^7+1*2^5+1*2^2+1*2^1+1*2^0=-128+32+4+2+1=\uuline{-89}$

\subsection{Zahlendarstellung mit beliebiger Basis}
\begin{description}
	\item[bin\"ar (2)] - Zahlen die mit 0b beginnen
	\item[octal (8)] - Zahlen die mit 0 beginnen
	\item[dezimal (10)] - Zahlen die nicht mit 0 beginnen
	\item[hex (16)] - Zahlen die mit 0x beginnen
\end{description}
Positive Zahlen: $\sum b_i+B^i$ mit $i \in [0,n-1]$ und $b_i$ gleich der Ziffer bei $i$. \\ \\
Ganze Zahlen: $-b_{n-1}*B^{n-1}+\sum b_i*B^i$ mit $i \in [0,n-2]$ und  $b_i$ Ziffer bei $i$.

\subsection{Gleitkommazahlen}
Exponentialdarstellung: $(-1)^V * (1+M)*2^E$ \\
IEEE 754 Float: $(-1)^V * (1+M) * 2^{E-127}$ \\
IEEE 754 Double: $(-1)^V * (1+M) * 2^{E-1023}$ \\
\begin{description}
	\item[V] - Vorzeichen (float 1Bit / double 1 Bit)
	\item[M] - normalisierte Mantrisse $(0 \leq M \leq 1)$ (float: 23 Bits / double: 52 Bits)
	\item[E] - Exponent (float: Signed-8-Bit $-$ 127  / double: Signed-11-Bit $-$ 1023)
\end{description} 
\begin{tabular}{|c|l|l|}
	\hline
	V & Exponent & Mantrisse \\
	\hline
\end{tabular}

\subsubsection{Beispiele (IEEE 754 32bit Float)}
\begin{description}
	\item[2.5] $=1.25*2^1$
	\item[-0.75] $=\underbrace{1}_{\ominus}\underbrace{01111110}_{-1 - 127} \underbrace{100000...}_{1+2^{-1}}=-1.5*2^{-1}$
	\item[0.1] $=\underbrace{0}_{\oplus}\underbrace{01110111}_{123 - 127} \underbrace{100\overline{1100}.........}_{1+2^{-1}+2^{-4}+2^{-5}...}=1.6*2^{-4} = 0.100000001490116119384765625$ 
\end{description}

\subsubsection{Spezialf\"alle}
\begin{description}
	\item[E=00000000 M=0] $\Rightarrow 0$
	\item[E=11111111 M=0 V=+] $\Rightarrow +\infty$
	\item[E=11111111 M=0 V=$-$] $\Rightarrow -\infty$
	\item[E=11111111 M$\neq$0] $\Rightarrow NaN$
\end{description}

\subsubsection{Division mit Null}
\begin{itemize}
	\item float f = $\pm$0.0f/$\pm$0.0f = $NaN$
	\item float f = 7.6f/0.0f = -7.6f/-0.0f = $+\infty$
	\item float f = -3.9f/0.0f = 3.9f/-0.0f = $-\infty$
\end{itemize}

\newpage
\section{Operationen \& Ausdr\"ucke}

\subsection{Auswertungsreihenfolge}
\begin{itemize}
	\item einstellige und mehrstellige Operatoren
		\begin{itemize}
			\item[1.] Teilausdr\"ucke in Klammern
			\item[2.] Ausdr\"ucke mit un\"aren Operatoren (pro Operand von rechts nach links)
			\item[3.] Teilausdr\"ucke mit mehrstelligen Operatoren gem\"ass Priorit\"atstabelle
		\end{itemize}
	\item mehrstellige Operatoren gleicher Priorit\"at \\
		bei gleicher Priorit\"at entscheidet die Assoziativit\"at (von links nach rechts oder von rechts nach links)
	\item Bewertungsreihenfolge von Operanden \\
		die Operanden eines Operators werden strikt von links nach rechts ausgewertet
\end{itemize}
\includegraphics[width=150mm]{operatoren_prios.png}

\subsection{Bitoperatoren}
logische oder auch Boolesche Operatore:
\begin{itemize}
	\item Operanden sind von einem ganzzahligen Datentyp
	\item Negation $\sim$a ($\sim 0 \equiv 1$ / $\sim 1\equiv 0$)
	\item AND a \& b
	\item OR a $|$ b
	\item XOR a $\wedge$  b
\end{itemize}
\begin{tabular}{|c|c|c|c|c|c|}
	\hline
	a & b & {a \& b} & a $|$ b & $\sim$a &  a $\wedge$  b \\
	\hline
	0 & 0 & 0 & 0 & 1 & 0 \\
	0 & 1 & 0 & 1 & 1 & 1 \\
	1 & 0 & 0 & 1 & 0 & 1 \\
	1 & 1 & 1 & 1 & 0 & 0 \\
	\hline
\end{tabular}

\subsection{Schiebeoperatoren}
\begin{itemize}
	\item Rechtsschiebe-Operatoren
		\begin{itemize}
			\item vorzeichenbehaftet: $a >> b$
			\item vorzeichenlos: $a >>> b$
		\end{itemize}
	\item Linksschiebe-Operator
		\begin{itemize}
			\item kann Vorzeichen ver\"andern:  $a << b$
		\end{itemize}
\end{itemize}

\subsubsection{1er-Bits z\"ahlen}
\begin{lstlisting}
public static int count(int x) {
	final int intSize = 32;  // Anzahl Bits einer Integer-Zahl
	int y = 0;               // output
	for (int i=0; i < intSize; i++) { 
		if (x%2 == 1) y++;
		x >>>= 1;
	}
	return y;
}

\end{lstlisting}

\subsubsection{effizienter Z\"ahler der 1er-Bits}
\begin{lstlisting}
public static int countEfficiently(int x) {
	int iEven, iOdd, d = 1;
	iEven = x & 0x55555555; x >>= d; iOdd = x & 0x55555555; 
	x = iOdd + iEven; d <<= 1 ;
	iEven = x & 0x33333333; x >>= d; iOdd = x & 0x33333333; 
	x = iOdd + iEven; d <<= 1 ;	
	iEven = x & 0x0F0F0F0F; x >>= d; iOdd = x & 0x0F0F0F0F; 
	x = iOdd + iEven; d <<= 1;	
	iEven = x & 0x00FF00FF; x >>= d; iOdd = x & 0x00FF00FF; 
	x = iOdd + iEven; d <<= 1 ;
	iEven = x & 0x0000FFFF; x >>= d; iOdd = x & 0x0000FFFF; 
	x = iOdd + iEven; d <<= 1 ;	
	return x;
}
\end{lstlisting}

\subsubsection{Ganzzahlige Addition}
\begin{lstlisting}
public static int add(int a, int b) {
	int c, r, t; // output r = a + b
	r = a^b; // Addition entspricht fast einer XOR-Operation 
	c = a&b; // Carry-Flags bestimmen
	while (c != 0) { // Carry-Flags hinzuaddieren
		c <<= 1;
		t = r; r ^= c; c &= t;
	}
	return r;
}
\end{lstlisting}

\subsubsection{Ganzzahlige Multiplikation}
\begin{lstlisting}
public static long mult(int a, int b) {
	long y = 0; // output y = a*b
	while (a != 0) {
		if (a%2 == 1) y += b; 
		b <<= 1;
		a >>= 1;
	}
	return y;
}
\end{lstlisting}

\subsection{Logische Operatoren}

\begin{itemize}
	\item logische oder auch Boolesche Operatoren
		\begin{itemize}
			\item Operanden sind vom Datentyp boolean
			\item logische Negation !A
			\item logisches UND A \&\& B  / A \& B \\
				(Bei zwei \& Zeichen wird erst A \"uberpr\"uft und B nur, falls A wahr ist.)
			\item logisches ODER A $||$ B / A $|$ B
		\end{itemize}
	\item Bedingungsoperator: A ? B : C \\
		if (A) then B else C
\end{itemize}

\subsection{Konvertierung von Datentypen}
\begin{itemize}
	\item explizite Typkonvertierung
		\begin{itemize}
			\item Konvertierungen sind m\"oglich:
				\begin{itemize}
					\item zwischen numerischen Datentypen (erweiternd und einschr\"ankend)
					\item zwischen Referenztypen
				\end{itemize}
			\item funktionieren gleich wie implizite, allerdings bestehen mehr M\"oglichkeiten
			\item cast-Operator: (Typname) Ausdruck
		\end{itemize}
	\item implizite (automatische) Typkonvertierung
		\begin{itemize}
			\item zwischen Operanden von numerischem Typ (nur erweiternd)
			\item zwischen Operanden von Referenztypen
			\item bei Verkn\"upfungen von String-Objekten mit Operanden anderer Typen \\
			    Object o = new Object();\\
			    String s = $"$X$"$+null+o;\\
			   String s = $"$X$"$+$"$null$"$+o.toString();\\
                                   String s = $"$Xnulljava.lang.Object@47ac1adf$"$;
		\end{itemize}
\end{itemize}

\subsubsection{Typkonvertierungen}
\begin{itemize}
	\item erweiternde Umwandlung \\
		Wert ist immer darstellbar \\
		m\"oglicher Verlust an Genauigkeit (z.B. bei Konvertierung von int nach float) \\ \\
		\includegraphics[width=75mm]{erweiternde_typumwandlung.png} \\
		
	\item einschr\"ankende Umwandlung \\
		m\"oglicher Informationsverlust in Gr\"osse, Vorzeichen \& Genauigkeit \\ \\
		\includegraphics[width=75mm]{einschraenkende_typumwandlung.png}
\end{itemize}

\subsubsection{Integer-Erweiterung}
\begin{itemize}
	\item Datentypen byte, short und char werden in Ausdr\"ucken mit un\"aren und bin\"aren Operatoren implizit in int konvertiert
		\begin{itemize}
			\item Dimensionsausdruck bei der Erzeugung von Arrays
			\item Indexausdruck in Arrays
			\item Operand der un\"aren Operatoren + und –
			\item Operand des Invertierungsoperators f\"ur Bits $\sim$
			\item Operanden der Schiebeoperatoren $>>$, $>>>$ und $<<$
		\end{itemize}
	\item byte, short und char werden somit fast ausschliesslich als Datenfelder f\"ur Klassen benutzt
\end{itemize}

\subsubsection{Implizite Konvertierung}
\begin{itemize}
	\item arithmetische Operatoren
		\begin{itemize}
			\item Ziel: gemeinsamer Typ f\"ur beide Operanden und somit auch f\"ur das Resultat
			\item Konvertierung in h\"oheren Typ gem\"ass Hierarchie
			\item Beispiele: \\ $c = (5.0/9)*(f - 32)$ \\ $x = 2*3L + 1.1$
		\end{itemize}
	\item Zuweisungsoperatoren
		\begin{itemize}
			\item zul\"assig sind nur erweiternde Konvertierungen mit der einen Ausnahme, wenn rechts ein konstanter Ausdruck vom Typ int steht, der darstellbar ist
			\item R\"uckgabewert von Methoden: wie bei Zuweisung
			\item Parameter\"ubergabe bei Methoden: wie Zuweisung aber ohne deren Ausnahme mit dem konstanten Ausdruck
		\end{itemize}
\end{itemize}

\subsubsection{Konvertierungsvorschriften}
\begin{itemize}
	\item erweiternde Konvertierung von vorzeichenbehafteten Integer-Typen \\
		Wert bleibt unver\"andert
	\item Konvertierung zwischen char und vorzeichenbehafteten Integer-Typen
		\begin{itemize}
			\item char ist vorzeichenlos
			\item bei gleicher Breite: Bitmuster bleibt erhalten
			\item char ist breiter: von links mit Nullen auff\"ullen und Vorzeichen propagieren
			\item char ist schmaler: kein korrektes Resultat, wenn Wert gr\"osser als $2^{16}$
		\end{itemize}
	\item Konvertierung von Integer nach Gleitpunkt \\
		n\"achst h\"oherer oder niedriger darstellbarer Wert
	\item Konvertierung von Gleitpunkt nach Integer
		\begin{itemize}
			\item Nachkommastellen werden abgeschnitten
			\item bei Werten gr\"osser als $2^{31} - 1$ ist das Resultat nicht korrekt ($= 2^{31} - 1$)
		\end{itemize}
	\item Konvertierung zwischen Gleitpunkt-Typen
		\begin{itemize}
			\item float nach double: Wert bleibt unver\"andert
			\item double nach float: Wert im zul\"assigen Wertebereich von float, dann n\"achst h\"oherer oder niedriger darstellbarer Wert
		\end{itemize}
\end{itemize}

\newpage
\section{Zeichen \& Strings}
\subsection{Wichtige Zeichencodes}

\subsection{Alte Zeichencodes}

\subsection{Unicode}

\subsubsection{UTF-16}

\subsubsection{UTF-8}


\newpage
\section{Suchen}

\subsection{Zahlensuche}
Generell gilt hier: Ordnung reduziert den Suchaufwand!

\subsubsection{Array einf\"ullen}
\begin{lstlisting}
final int n=10000;
int[] array=new int[n];
for(int i=0;i<array.length;i++) {
  array[i] = (int) (Math.random()*Integer.MAX_VALUE);
}
\end{lstlisting}

\subsubsection{Lineare Suche}
\begin{lstlisting}
int i=0;
while(i<array.lenght && array[i]!=x) i++;
boolean gefunden = (i < array.length);
\end{lstlisting}

\subsubsection{Lineare Suche mit W\"achter (Sentinel)}
\begin{lstlisting}
boolean gefunden = false;
int last = (array.length-1);
if (array[last]==x) {
  gefunden=true;
} else {
  int tmp = array[last];
  array[last]=x;
  int i=0;
  while(array[i] != x) i++;
  gefunden = (i < last);
  array[last] = tmp;
}
\end{lstlisting}

\subsubsection{Bin\"are Suche}
\begin{lstlisting}
boolean binarySearch(double[] array, double x) {
  int first=0, last=array.lenght-1, m;
  while(first <= last) {
    m = first + (first - last) / 2;  //schneller (m=(first+last)>>>1)
    if(array[m] == x) return true;
    else if (array[m] < x) first=m+1;
    else last=m-1;
  }
}
\end{lstlisting}

\subsubsection{Analyse}
\begin{tabular}{l | l | c | c | c }
	Typ & Laufzeit & n & 256 & $2^{20}$ \\
	\hline
	Lineare Suche & lineare Laufzeit & n & 256 & $2^{20}$ \\
	Bin\"are Suche & logarithmisch & $[log_{2}(n)]+1$ & 9 & 21
\end{tabular}

\subsection{Textsuche}
\subsubsection{Naive Textsuche}
\begin{tabular}{l c c c c c c c l}
	text: & a & e & e & i & e & i & n & (n Zeichen) \\
	pattern: & e & i & n & & & & & (m Zeichen) \\
	& \lightning & e & i & n \\
	& & \checkmark & \lightning \\
	& & & e & i & n \\
	& & & \checkmark & \checkmark & \lightning \\
	& & & & e & i & n \\
	& & & & \lightning & e & i & n \\
	& & & & & \checkmark & \checkmark & \checkmark \\
\end{tabular} \\ \\
Auswertung: $T(n,m) = m(n-m+1)=m*n-m^2+m$

\subsubsection{Knuth-Morris-Pratt (KMP)}
Als erstes wird beim KMP das zu suchende Pattern untersucht. Das Pattern wird mit sich selber verglichen. Das Ziel ist zu wissen, bei welchem Buchstaben des Patterns man bei einem Missmatch weitermachen soll. \\
Es wird f\"ur jedes Teilst\"uck des Patterns das Endst\"uck maximaler L\"ange gesucht, welches einem Anfangsst\"uck entspricht. Dann wird abgespeichert, wo mit dem Vergleichen fortgefahren werden muss, wenn an dieser Stelle ein Fehler auftritt. \\ \\
\begin{tabular}{|c|c|c|c|c|c|c|c|}
	\hline 
	0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
	\hline
	h & a & u & s & h & a & l & t \\
	\hline
	-1 & 0 & 0 & 0 & 0 & 1 & 2 & 0 \\
	\hline
\end{tabular} \\ \\ \\
Die Tabelle Zeigt die Verschiebeinformationen f\"ur das Beispiel. Wenn beim Vergleich der Position 5 mit dem Text ein Fehler auftritt, dann muss bei Position 1 (also 1 wieder verglichen werden). Nur f\"ur den Anfangsbuchstaben ist der Wert -1. Wenn dieser genommen wird, heisst das, dass das Pattern wieder von vorne verglichen werden muss. \\
Diese Verschiebeinformationen werden zu Beginn der Suche im Text berechnet. Damit muss bei der Suche nie ein Teilst\"uck zweimal durchsucht werden. \\

\Bold{Implementierung:}

\begin{lstlisting}
public class KPM {
    String m_text;
    String m_pattern;
    int[] m_next;

    public KPM(String text, String pattern) {
        m_text = text;
        m_pattern = pattern;
        m_next = new int[pattern.length()];
    }
    
    public void initnext() {
        int i = 0; // wird das Pattern einmal durchlaufen
        int j = -1; // wird zum Vergleich mit dem Anfagsst¸ck verwendet

        m_next[i] = j;
        while (i < m_pattern.length() - 1) {
            if (j < 0 || m_pattern.charAt(i) == m_pattern.charAt(j)) {
                i++;
                j++;
                m_next[i] = j;

            } else {
                j = m_next[j];
            }
        }
    }

    public void search_kmp() {
        int t = 0;
        int p = 0;

        while (t < m_text.length()) {
            // p weiss, mit was im Pattern verglichen werden muss
            // t geht durch den Text
            if ((p < 0) || m_text.charAt(t) == m_pattern.charAt(p)) {
                t++;
                p++;
            } else {
                p = m_next[p];
            }
            if (p == m_pattern.length()) {
                System.out.println("Gefunden, Uebereinstimmung startet bei "
                        + (t - p + 1) + ". Zeichen");
                p = 0;
            }
        }
    }   
    
    public static void main(String[] args) {
         KPM kpm = new KPM("baabcabac", "bac");
         kpm.initnext();
         kpm.search_kmp();
    }
}
\end{lstlisting}

\newpage
\section{Sortieren}
Ein Array a ist sortiert, wenn gilt: \\ \\
$ \forall i \in [0, a.lenght-2] : a[i]\ relop\ a[i+1]$ \\
relop: Relation, Bin\"ares Pr\"adikat (typisch: $\leq,\geq,<,>$)

\subsection{\"Uberpr\"ufen, ob das Array sortiert ist}

\begin{lstlisting}
i=0;
while(i<a.lenght-1 && a[i] relop a[i+1]) i++;
boolean sortiert = (i==a.length-1);
\end{lstlisting}
Aufwand: linear in der L\"ange des Arrays \\

\subsection{Sortieren durch direktes Ausw\"ahlen (selection sort)}
Das Array wird durch gegangen und nach dem gr\"ossten Element durchsucht. Einmal gefunden, wird es hinten hingesetzt. Danach wird das zweitgr\"osste Element gesucht und vor das gr\"osste Element gestellt. Wenn man dies weiterf\"uhrt w\"achst der sortierte Teil des Arrays kontinuierlich, w\"ahrend der unsortierte Teil kleiner wird.
\begin{lstlisting}
int k, max; //k = index of max ; max = value of max
for (int last = a.length - 1; last > 0; last--) {
  k = 0;
  max = a[k];
  for (int j = 1; j <= last; j++) {
    if (a[j] > max) {
      max = a[k = j];
    }
  }
  if(k!=last){
    a[k] = a[last];
    a[last] = max;
  }
}
\end{lstlisting}
Worst-Case Aufwand: $T(n)=1+2+3+...+(n-3)+(n-2)+(n-1)=\sum^{n-1}_{k=1} k=\frac{n(n-1)}{2}=\frac{n^2-n}{2}\approx\uuline{\frac{n^2}{2}}$

\subsection{Sortierten durch direktes einf\"ugen (insertion sort)}
Das Array wird durch gegangen und jedes Element an der richtigen Stelle, der bereits durch gegangenen Elemente, eingesetzt.
\begin{lstlisting}
for(int first=1; first<a.length;first++) {
  tmp=a[first];
  k=first-1;
  while(k>=0 && a[k]>tmp) {
    a[k+1]=a[k];
    k--;
  }
  a[k+1] = tmp;
}
\end{lstlisting}
Worst-Case Aufwand: $T(n)=1+2+3+...+(n-3)+(n-2)+(n-1)=\sum^{n-1}_{k=1} k=\frac{n(n-1)}{2}=\frac{n^2-n}{2}\approx\uuline{\frac{n^2}{2}}$
Durchschnitt: $T(n)=0.5 + 1 + 1.5 + ... + \frac{(n-3)}{2} + \frac{(n-2)}{2} + \frac{(n-1)}{2}  + \frac{n}{2}=\sum^{n-1}_{i=1} \frac{i}{2}=\frac{1}{2}*\sum^{n-1}_{i=1} i = \frac{1}{2}*(\frac{n^2-n}{2})\approx\uuline{\frac{n^2}{4}}$

\section{Halbdynamischen Datenstrukturen}

\subsection{Das Array}

\begin{itemize}
	\item[Vorteile] 
		\begin{itemize}
			\item hohe Zeiteffizienz, weil auf alle Elemente des Arrays direkt zugegriffen werden kann
			\item hohe Speichereffizienz, wenn die Anzahl der Elemente des Arrays konstant bleibt
		\end{itemize}
	\item[Nachteile] 
		\begin{itemize}
			\item wenn sich die Anzahl Elemente w\"ahrend der Ausf\"uhrung eines Algorithmus stark \"andert, so ist die Speichereffizienz nur bedingt gut
			\item wenn zu Beginn des Algorithmus unklar ist, wie viele Elemente maximal abgespeichert werden m\"ussen, so ist die Datenstruktur Array in Reinform wenig hilfreich.
		\end{itemize}
\end{itemize}

\subsection{Datenstrukturen}

\subsubsection{statische Datenstruktur: Array}
\begin{itemize}
	\item fixer Speicherbedarf, unabh\"angig von der Anzahl genutzter Elemente im Array
	\item direkter Zugriff auf die Elemente des Arrays
\end{itemize}

\subsubsection{halbdynamische Datenstruktur}
\begin{itemize}
	\item Speicherbedarf passt sich schrittweise der genutzten Anzahl Elemente an und bleibt zwischendrin konstant
	\item direkter Zugriff auf die Elemente
	\item Anpassung des Speicherbedarfs ist zeitaufw\"andig
\end{itemize}

\subsubsection{dynamische Datenstrukturen: Liste, Stack, Baum usw.}
\begin{itemize}
	\item Speicherbedarf h\"angt direkt von der genutzten Anzahl Elemente ab
	\item \"ublich unterst\"utzte Operationen: Suchen, Einf\"ugen, Entfernen
	\item indirekter Zugriff auf die Elemente
\end{itemize}

\subsubsection{Datennutzung \"uber die Zeit}
\includegraphics[width=150mm]{datennutzung_ueber_zeit.png}

\subsection{Das ArrayList}
\begin{itemize}
	\item ArrayList verwendet intern ein Array von Objekten
	\item die L\"ange des Arrays entspricht der Kapazit\"at
	\item die verwendete Anzahl Elemente ist in size gespeichert
	\item Eine ArrayList startet mit der Gr\"osse 10 wenn nicht's anderes angegeben wurde
	\item Die Kapazit\"at wird erh\"oht, wenn die ArrayList voll ist und ein neues Element hinzugef\"ugt wird.
	\item Die neue Kapazit\"at wir bei der Erh\"ohung wie folgt berechnet:\\
			JRE1.6: $cap_{new}=(cap_{old} * 3) / 2 + 1$\\
			JRE1.7: $cap_{new}=cap_{new} + (cap_{old} >> 1)$
\end{itemize}

\subsubsection{Interner Aufbau (bis Java 1.4.2)}
\begin{itemize}
	\item alle Klassen aus dem Java Collections Framework verwalten intern Referenzen vom Typ Object \\ $\Rightarrow$ maximale Flexibilit\"at
	\item alle Methodenschnittstellen verwenden den Typ Object
	\item da alle Referenztypen zur Klasse Object zuweisungskompatibel sind, bieten die Collections keine Typsicherheit
\end{itemize}

\subsubsection*{Code:}
\begin{itemize}
	\item void add(int index, Object element)
	\item void clear()
	\item boolean contains(Object o)
	\item Object get(int index)
	\item  int indexOf(Object o)
	\item boolean isEmpty()
	\item ListIterator listIterator(int index) 
	\item  Object remove(int index)
	\item boolean remove(Object o)
	\item Object set(int index, Object element) 
	\item  int size()
	\item ...
\end{itemize}

\subsubsection{Interner Aufbau (seit Java 5.0)}
\begin{itemize}
	\item alle Collections verwalten intern Referenzen vom Typ $<$E$>$, wobei E ein beliebiger Platzhalter (Typ-Parameter) f\"ur einen konkreten Referenztyp ist
	\item Collections werden generisch (maximale Flexibilit\"at)
	\item Collections k\"onnen f\"ur alle m\"oglichen Referenztypen verwendet werden, auch
f\"ur Object (= fr\"uherer interner Aufbau)
\end{itemize}

\newpage
\section{Programmverifikation}
\subsection{Einleitung}
\subsubsection{Black and White}
\begin{description}
	\item[Gegeben:] \hfill
		\begin{itemize}
			\item Beh\"alter mit w weissen Kugeln und b schwarzen Kugeln
			\item mindestens eine Kukel ist im Beh\"alter: $b + w \geq 1$
		\end{itemize}
	\item[Ablauf:] \hfill
		\begin{itemize}
			\item solange wenigstens zwei Kugeln im Beh\"alter sind, zuf\"allig zwei Kugeln rausnehmen und ...
			\item haben beide herausgenommenen Kugeln die gleiche Farbe \\
				$\rightarrow$ eine weisse ugel in den Beh\"alter legen
			\item haben beide herausgenommenen Kugeln unterschiedliche Farben \\
				$\rightarrow$ schwarze Kugel in den Beh\"alter zur\"ucklegen
		\end{itemize}
	\item[Gesucht] \hfill
		\begin{itemize}
			\item Terminiert dieser Ablauf?
			\item Falls ja, wie und wovon h\"angt die Schlusssituation ab?
		\end{itemize}
\end{description}

\begin{description}
	\item[Frage 1:] Ja, der Prozess Terminiert, da es bei jedem Schritt eine Kugel weniger wird.
	\item[Frage 2:] Bei allen drei m\"oglichen Schritten, ver\"andert sich die Parit\"at von b nicht. Das bedeutet, dass wenn am Ende eine Schwarze Kugel \"ubrig ist muss am Anfang eine ungerade Anzahl Kugeln in dem Beh\"alter gewesen sein.
\end{description}
Man untersucht einen Prozess darauf, was sich w\"arend dem Prozess ver\"andert (Variante) und was nicht (Invariante). Findet man heraus, was sich nicht ver\"andert kann man von der Schlusssituation R\"uckschl\"usse auf die Startsituation treffen.
\begin{description}
	\item[Variante:] Anzahl Kugeln im Berh\"alter wird dekremiert
	\item[Invariante:] Parity(b)
\end{description}

\subsubsection{Verbindungslinien}
\begin{description}
	\item[Gegeben:] \hfill
		\begin{itemize}
			\item n scharze und n weisse Punkte in der Ebene
			\item keine drei Punkte kollinear (in einer Reihe)
		\end{itemize}
	\item[Ablauf:] \hfill
		\begin{itemize}
			\item je ein weisser und ein scharzer Ounkt werden mit einer Strecke verbunden
			\item jeder Punkt darf nur mit einem andern Punkt verbunden werden
		\end{itemize}
	\item[Gesucht] \hfill
		\begin{itemize}
			\item Existiert eine schnittfreie Anordnung der Verbindungsstrecken?
			\item Falls ja, wie findet man eine solche?
		\end{itemize}
\end{description}
Ja es gibt immer eine schnittfreie Anordung der Verbindungsstrecken. Am besten findet man diese, wenn man die Punkte einmal beliebig verbindet und danach alle gekreuzten Linien vertauscht (swapt).

\begin{description}
	\item[Variante:] Die gesamtl\"ange aller Linien nimmt ab
	\item[Invariante:] Die Anzahl Linien nimmt ab.
\end{description}

\subsection{Korrektheit eines Algorithmus}
Ein Algorithmus heisst \Bold {korrekt}, wenn er seinen Spezifikationen gen\"ugt, wenn er zu allen Eingabedaten, die der Vorbedingung (Pre Conditions) gen\"ugen, die Ausgabedaten erzeugt, welche die Nachbedinungen (Post Condition) erf\"ullen. 
\begin{description}
	\item[Vorbedingung (Precondition)] \hfill \\
		Ein Algorithmus muss in einem klar definierten Zustand starten, andernfalls sind keine klaren Aussagen \"uber seine Arbeitsweise m\"oglich. Alle Parameterwerte des Algorithmus m\"ussen innerhalb der spezifizierten Wertebereiche liegen.
	\item[Nachbedingung (Postcondition)] \hfill \\
		Die Ausgabe (Endwerte) eines Algorithmus muss der Spezifikation.
entsprechen
\end{description}

\subsection{Aussagelogik}
\subsubsection{Syntax}
		\begin{itemize}
			\item atomare Formeln (Atome): A, B, C, ...
			\item seien F und G zwei beliebige Formeln
				\begin{itemize}
					\item Konjunktion: $(F \wedge G)$ ist eine Formel
					\item Disjunktion: $(F \vee G)$ ist eine Formel
					\item Negation: $\neg F$ ist eine Formel
					\item Implikation: $(F \rightarrow G)$ ist eine Kurzschreibweise f\"ur $(\neg F \vee G)$
					\item Bikonditional: $(F \leftrightarrow G)$ ist eine Kurzschreibweise f\"ur $(F \ra G) \wedge (G \ra F)$
				\end{itemize}
		\end{itemize}
		
\subsubsection{Semantik}
		\begin{itemize}
				\item Belegung B: eine Teilmenge der atomaren Formeln wird mit einem Wahrheitswert aus {false, true} bzw. {0,1} belegt
				\item die Bedeutungen der Konjunktion, Disjunktion und Negation sind analog zur Bool'schen Algebra definiert
				\item passende Belegung B auf Formel F angewendet: B(F)
		\end{itemize}
		
\subsubsection{Modell}
		\begin{itemize}
			\item eine Belegung heisst zu einer Formel F \Bold {passend}, wenn alle in F
vorkommenden Atome belegt sind
			\item eine Belegung B ist ein \Bold {Modell} f\"ur eine Formel F, wenn sie passend ist
und wenn der Wahrheitswert von B(F) = true ist: $B \models F$
			\item Belegung ist B \Bold {kein Modell} f\"ur Formel F, wenn sie zwar passend ist,
aber wenn der Wahrheitswert von B(F) = false ist: $B \nvDash F$
		\end{itemize}
		
\subsubsection{Erf\"ullbarkeit}
\begin{itemize}
	\item Eine Formel F heisst \Bold {erf\"ullbar}, wenn f\"ur sie ein Modell existiert, andernfalls \Bold {unerf\"ullbar}
	\item Eine Formel F heisst \Bold {g\"ultig} (oder Tautologie), wenn alle passenden Belegungen Modelle sind: $ \models F$
\end{itemize}

\subsubsection{\"Aquivalenz}
Zwei Formeln F und G heissen (semantisch) \"aquivalent, falls f\"ur alle passenden Belegungen B gilt: B(F) = B(G). Daf\"ur schreiben wir $\models (F \leftrightarrow G)$ oder kurz $F \equiv G$. \\ \\
\begin{tabular}{l l c | c l l}
\multicolumn{2}{c}{AND} &&& \multicolumn{2}{c}{OR} \\
\hline 
&&&&& \\
$(F \wedge F)$                    & $\equiv F$                                                 &&& $(F \vee F)$ & $\equiv F$ \\
$(F \wedge G)$                   & $\equiv (G \wedge F)$                               &&& $(F \vee G)$ & $\equiv (G \vee F)$ \\
$((F \wedge G) \wedge H)$ & $\equiv (F \wedge (G \wedge H))$             &&& $((F \vee G) \vee H)$ & $\equiv (F \vee (G \vee H))$ \\
$(F \wedge (F \vee G))$      & $\equiv F$                                                 &&& $(F \vee (F \wedge G))$ & $\equiv F$ \\
$(F \wedge (G \vee H))$     & $\equiv ((F \wedge G) \vee (F \wedge H))$ &&& $(F \vee (G \wedge H))$ & $\equiv ((F \vee G) \wedge (F \vee H))$ \\
$\neg (F \wedge G)$          & $\equiv (\neg F \vee \neg G)$                    &&& $\neg (F \vee G)$ & $\equiv (\neg F \wedge \neg G)$ \\
$(F \wedge G)$                  & $\equiv G$, falls $\models F$                    &&& $(F \vee G)$ & $ \equiv G$, falls $\models F$ \\
$(F \wedge G)$                  & $\equiv$ F, falls F unerf\"ullbar                 &&& $(F \vee G)$ & $\equiv$ F, falls F unerf\"ullbar \\

\end{tabular}

\subsection{Pr\"adikatenlogik}
\subsubsection{Syntax}
\begin{itemize}
	\item Erweiterung der Aussagenlogik um Quantoren, Funktionen, Pr\"adikate, Relationen und Variablen
		\begin{itemize}
			\item nullstellige Pr\"adikate entsprechen den Atomen der Aussagelogik
			\item Relationen k\"onnen als Pr\"adikate aufgefasst werden
			\item nullstellige Funktionen sind Konstanten
		\end{itemize}
	\item Formeln
		\begin{itemize}
			\item logische Verkn\"upfung von Pr\"adikaten: \\
				die Argumente der Pr\"adikate sind Terme, gebildet aus Funktionen, Variablen und Konstanten
			\item sei x eine Variable und F eine Formel
				\begin{itemize}
					\item $\forall$ x F ist eine Formel mit gebundenem x
					\item $\exists$ x F ist eine Formel mit gebundenem x
				\end{itemize}
			\item eine Formel heisst geschlossen oder Aussage, wenn alle ihre Variablen durch Quantoren gebunden sind
		\end{itemize}
	\item Pr\"adikatenlogik mit Identit\"at \\
		wenn F und G zwei Formeln sind, so ist auch F = G eine Formel
\end{itemize}

\subsubsection{Semantik}
\begin{itemize}
	\item Struktur $S = (U_s, I_s)$ \\
		$U_s$ ist eine nicht-leere Grundmenge und IS eine Abbildung
		\begin{itemize}
			\item der Pr\"adikate \"uber $U_s$
			\item der Funktionen auf $U_s$
			\item der Variablen auf Elemente von $U_s$
		\end{itemize}
	\item Semantik bez\"uglich passender Struktur S
		\begin{itemize}
			\item[S(Term)] jeder Term wird gem\"ass IS auf ein Element aus US abgebildet
			\item[S(Pr\"adikat)] jedes Pr\"adikat bestimmt einen Wahrheitswert in Abh\"angigkeit seiner Argumente (Terme)
			\item[S(Formel)] die aussagenlogische Verkn\"upfung der Wahrheitswerte der Pr\"adikate
			\item[S($\forall$x F)] F ist eine Formel 
				\begin{itemize}
					\item ist true, falls f\"ur alle d $\in$ US gilt: $S_{[x/d]}(F) = true$
					\item ist false, sonst
				\end{itemize}
			\item[S($\exists$x F)] F ist eine Formel
				\begin{itemize}
					\item ist true, falls f\"ur alle d $\in$ US gilt: $S_{[x/d]}(F) = true$
					\item ist false, sonst
				\end{itemize}
		\end{itemize}
\end{itemize}

\subsubsection{\"Aquivalenz}
\begin{description}
	\item[Definition] \hfill \\
		Zwei pr\"adikatenlogische Formeln F und G sind \"aquivalent, falls f\"ur alle passenden Strukturen S gilt: S(F) = S(G). Daf\"ur schreiben wir F $\equiv$ G.
	\item[\"Aquivalenzregeln (zus\"atzlich zur Aussagenlogik)] \hfill \\
		$\neg \forall x F \equiv \exists x \neg F$ \\
		$\forall x \forall y F \equiv \forall y \forall x F$ \\
		$(\forall x F \wedge \forall x G) \equiv \forall x (F \wedge G)$ \\
		$\neg \exists x F \equiv \forall x \neg F$ \\		
		$\exists x \exists y F \equiv \exists y \exists x F$ \\
		$(\exists F \vee \exists x G) \equiv \exists x (F \vee G)$ \\ \\
		falls x in G nicht frei vorkommt, gilt: \\
		$(\forall x F \wedge G) \equiv \forall x (F \ wedge G)$ \\
		$(\forall x F \vee G) \equiv \forall x (F \vee G)$ \\
		$(\exists x F \wedge G) \equiv \exists x (F \wedge G)$ \\
		$(\exists x F \vee G) \equiv \exists (F \vee G)$ \\
\end{description}

\subsubsection{Beispiele}
\begin{description}
	\item[Alle Studierenden von Professor p m\"ogen Logik.] \hfill \\
		L(x) : "x mag Logik" \\
		S(x,y) : "x studiert bei y" \\
		$\forall x: S(x,p) \ra L(x)$ \\
		$\forall x: \neg S(x,p) \vee L(x)$
	\item[Ein Professor ist gl\"ucklich, wenn alle seine Studierenden Logik m\"ogen] \hfill \\
		G(x) : "x ist gl\"ucklich" \\
		$\exists y: (\forall x : S(x,y) \ra L(x)) \ra G(y)$
	\item[Ein Professor ist ungl\"ucklich, wenn er keine Studierende hat.] \hfill \\
		$\exists y: (\forall x : \neg S(x,y)) \ra \neg G(y)$
\end{description}
\end{document}



	
